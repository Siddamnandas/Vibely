import { generateAlbumCover } from "@/ai/flows/generate-album-cover";
import { songs } from "@/lib/data";

async function urlToDataUri(url: string): Promise<string> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.statusText} from ${url}`);
    }
    const blob = await response.blob();
    const buffer = Buffer.from(await blob.arrayBuffer());
    const dataUri = `data:${blob.type};base64,${buffer.toString("base64")}`;
    return dataUri;
  } catch (error) {
    console.error("Error converting URL to Data URI:", error);
    throw new Error("Could not process image URL.");
  }
}

export interface GenerateCoverInput {
  trackMeta: {
    id: string;
    title: string;
    artist: string;
    originalCoverUrl: string;
  };
  userGalleryHint?: string; // Data URI of selected photo
}

export interface GenerateCoverOutput {
  imageUrl: string;
  variantId: string;
}

export async function generateCover({
  trackMeta,
  userGalleryHint,
}: GenerateCoverInput): Promise<GenerateCoverOutput> {
  try {
    // Find the song data
    const song = songs.find((s) => s.id === trackMeta.id);
    if (!song) {
      throw new Error(`Song not found: ${trackMeta.id}`);
    }

    // If no user photo provided, return a placeholder
    if (!userGalleryHint) {
      const placeholderUrl = `https://picsum.photos/seed/${trackMeta.id}-${Date.now()}/500/500`;
      return {
        imageUrl: placeholderUrl,
        variantId: `placeholder_${trackMeta.id}_${Date.now()}`,
      };
    }

    // Call the AI to generate the cover
    const result = await generateAlbumCover({
      photoDataUri: userGalleryHint,
      songTitle: trackMeta.title,
      artistName: trackMeta.artist,
      originalCoverDataUri: await urlToDataUri(trackMeta.originalCoverUrl),
    });

    // Use the first generated variant
    if (result.generatedCoverUris && result.generatedCoverUris.length > 0) {
      // For production, we should save the image to a stable URL
      // For now, we'll return the data URI but in production this should be a stable URL
      const imageUrl = result.generatedCoverUris[0];

      // In production, you would upload this to a storage service and return a stable URL
      // For example:
      // const stableUrl = await uploadToStorage(imageUrl, `covers/${trackMeta.id}_${Date.now()}.jpg`);
      // return {
      //   imageUrl: stableUrl,
      //   variantId: `ai_${trackMeta.id}_${Date.now()}`,
      // };

      return {
        imageUrl,
        variantId: `ai_${trackMeta.id}_${Date.now()}`,
      };
    } else {
      throw new Error("No cover generated by AI");
    }
  } catch (error) {
    console.error("AI cover generation failed for track", trackMeta.id, error);
    // Fall back to a placeholder image
    const fallbackUrl = `https://picsum.photos/seed/fallback-${trackMeta.id}-${Date.now()}/500/500`;
    return {
      imageUrl: fallbackUrl,
      variantId: `fallback_${trackMeta.id}_${Date.now()}`,
    };
  }
}

// In a production implementation, you would have a function like this:
// async function uploadToStorage(dataUri: string, filename: string): Promise<string> {
//   // Convert data URI to blob
//   const base64Data = dataUri.split(',')[1];
//   const byteString = atob(base64Data);
//   const mimeString = dataUri.split(',')[0].split(':')[1].split(';')[0];
//   const ab = new ArrayBuffer(byteString.length);
//   const ia = new Uint8Array(ab);
//   for (let i = 0; i < byteString.length; i++) {
//     ia[i] = byteString.charCodeAt(i);
//   }
//   const blob = new Blob([ab], { type: mimeString });
//
//   // Upload to storage service (e.g., Firebase Storage, AWS S3, etc.)
//   // Return the public URL
//   // const storageRef = ref(storage, filename);
//   // const snapshot = await uploadBytes(storageRef, blob);
//   // return await getDownloadURL(snapshot.ref);
//
//   // For now, just return the data URI
//   return dataUri;
// }
